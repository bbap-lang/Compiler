using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;

namespace SourceGenerator {
    [Generator]
    public class StatementPartGenerator: ISourceGenerator {
        public void Execute(GeneratorExecutionContext context) {
            var atributeType = typeof(StatementPartAttribute);

            var treesWithlassWithAttributes = context.Compilation.SyntaxTrees.Where(st => st.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>()
                        .Any(p => p.DescendantNodes().OfType<AttributeSyntax>().Any()));

            List<ClassWrapper> classes = new List<ClassWrapper>();
            foreach (var tree in treesWithlassWithAttributes) {
                var declaredClass = tree
                                    .GetRoot()
                                    .DescendantNodes()
                                    .OfType<ClassDeclarationSyntax>()
                                    .Where(cd => cd.DescendantNodes().OfType<AttributeSyntax>().Any());

                var semanticModel = context.Compilation.GetSemanticModel(tree);
                var classesWithAttribute = declaredClass.Where(c => ImplementsAtributes(c, semanticModel)).ToList();
                var classWrapped = classesWithAttribute.Select(x => new ClassWrapper(GetNamespace(x, semanticModel), semanticModel.GetDeclaredSymbol(x).Name)).ToList();
                classes.AddRange(classWrapped);
            }

            foreach(var className in classes) {
                context.AddSource(className.Name + ".g.StatementPart.cs", SourceText.From($@"
                    // <auto-generated>
                    using BBAP.Data.Contexts.Statements;
                    namespace {className.Namespace};
                    public partial class {className.Name} : IStatementPart{{
                        public ReadOnlyMemory<char> String {{ get; set; }}
                        public bool Finished {{ get; set; }}
                        public List<IStatementPart> Inner {{ get; set; }}
                    }}
                ", Encoding.UTF8));
            }
        }

        private bool ImplementsAtributes(ClassDeclarationSyntax classDeclaration, SemanticModel semanticModel) {
            var atributes = classDeclaration.AttributeLists.SelectMany(al => al.Attributes).ToList();
            return atributes.Any(a => semanticModel.GetTypeInfo(a).Type.Name == typeof(StatementPartAttribute).Name);
        }

        private string GetNamespace(ClassDeclarationSyntax classDeclaration, SemanticModel semanticModel) {
            var parent = classDeclaration.Parent;
            return semanticModel.GetDeclaredSymbol(parent).ToDisplayString();
        }

        public void Initialize(GeneratorInitializationContext context) {
            // No initialization required for this one
        }

        private readonly struct ClassWrapper {
            public ClassWrapper(string @namespace, string name) {
                Namespace = @namespace;
                Name = name;
            }

            public string Namespace { get; }
            public string Name { get; }
        }
    }
}